"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[2622],{8413:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module1-ros2/python-agents-to-controllers","title":"Python Agents to ROS Controllers","description":"This chapter focuses on integrating intelligent Python agents with ROS 2 to control robotic systems. We\'ll explore how to design and implement Python code that can interact with ROS 2 topics, services, and actions to command robots, process sensor data, and execute complex behaviors.","source":"@site/docs/module1-ros2/python-agents-to-controllers.md","sourceDirName":"module1-ros2","slug":"/module1-ros2/python-agents-to-controllers","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1-ros2/python-agents-to-controllers","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module1-ros2/python-agents-to-controllers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to ROS 2","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1-ros2/introduction"},"next":{"title":"Understanding URDF (Unified Robot Description Format)","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1-ros2/understanding-urdf"}}');var i=s(4848),t=s(8453);const o={},a="Python Agents to ROS Controllers",l={},c=[{value:"3.1 Basics of <code>rclpy</code>",id:"31-basics-of-rclpy",level:2},{value:"Initializing and Shutting Down ROS 2 in Python",id:"initializing-and-shutting-down-ros-2-in-python",level:3},{value:"Creating Nodes, Publishers, Subscribers, Service Clients/Servers, Action Clients/Servers",id:"creating-nodes-publishers-subscribers-service-clientsservers-action-clientsservers",level:3},{value:"Node",id:"node",level:4},{value:"Publisher",id:"publisher",level:4},{value:"Subscriber",id:"subscriber",level:4},{value:"Service Client and Server",id:"service-client-and-server",level:4},{value:"3.2 Python Agents to ROS Controllers",id:"32-python-agents-to-ros-controllers",level:2},{value:"Writing Simple Control Loops in Python",id:"writing-simple-control-loops-in-python",level:3},{value:"Interfacing with Simulated Robot Joint States and Commands",id:"interfacing-with-simulated-robot-joint-states-and-commands",level:3},{value:"3.3 Advanced <code>rclpy</code> Features",id:"33-advanced-rclpy-features",level:2},{value:"Timers and Callbacks",id:"timers-and-callbacks",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Logging",id:"logging",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"python-agents-to-ros-controllers",children:"Python Agents to ROS Controllers"})}),"\n",(0,i.jsx)(n.p,{children:"This chapter focuses on integrating intelligent Python agents with ROS 2 to control robotic systems. We'll explore how to design and implement Python code that can interact with ROS 2 topics, services, and actions to command robots, process sensor data, and execute complex behaviors."}),"\n",(0,i.jsxs)(n.h2,{id:"31-basics-of-rclpy",children:["3.1 Basics of ",(0,i.jsx)(n.code,{children:"rclpy"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rclpy"})," is the Python client library for ROS 2, providing an intuitive interface to all core ROS 2 functionalities. It allows Python developers to write ROS 2 nodes, publishers, subscribers, service clients and servers, and action clients and servers."]}),"\n",(0,i.jsx)(n.h3,{id:"initializing-and-shutting-down-ros-2-in-python",children:"Initializing and Shutting Down ROS 2 in Python"}),"\n",(0,i.jsxs)(n.p,{children:["Every ROS 2 Python application must initialize the ",(0,i.jsx)(n.code,{children:"rclpy"})," library and create a node."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\ndef main(args=None):\n    # Initialize rclpy library\n    rclpy.init(args=args)\n\n    # Create a node\n    node = Node('my_python_node')\n    node.get_logger().info('My Python Node started!')\n\n    # Keep the node alive (e.g., waiting for messages or service calls)\n    rclpy.spin(node)\n\n    # Destroy the node once spin() returns\n    node.destroy_node()\n\n    # Shutdown rclpy library\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"creating-nodes-publishers-subscribers-service-clientsservers-action-clientsservers",children:"Creating Nodes, Publishers, Subscribers, Service Clients/Servers, Action Clients/Servers"}),"\n",(0,i.jsx)(n.p,{children:"The examples below provide a quick overview of how to create each communication primitive. For detailed explanations, refer to the previous chapter and ROS 2 documentation."}),"\n",(0,i.jsx)(n.h4,{id:"node",children:"Node"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Node"})," is the fundamental unit. All ROS 2 communication happens through methods of a ",(0,i.jsx)(n.code,{children:"Node"})," object."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n    def __init__(self):\n        super().__init__('my_custom_node')\n        self.get_logger().info('My Custom Node has been initialized!')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    my_node = MyNode()\n    rclpy.spin(my_node)\n    my_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h4,{id:"publisher",children:"Publisher"}),"\n",(0,i.jsx)(n.p,{children:"To send data to a topic."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String # Import the message type\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10) # Topic name: chatter, Queue size: 10\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello from Python: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h4,{id:"subscriber",children:"Subscriber"}),"\n",(0,i.jsx)(n.p,{children:"To receive data from a topic."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter', # Subscribe to the 'chatter' topic\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h4,{id:"service-client-and-server",children:"Service Client and Server"}),"\n",(0,i.jsxs)(n.p,{children:["For request-reply communication. Assuming ",(0,i.jsx)(n.code,{children:"example_interfaces.srv.AddTwoInts"})," is available."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Service Server:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Service server \"add_two_ints\" is ready.')\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info('Incoming request\\na: %d b: %d -> sum: %d' % (request.a, request.b, response.sum))\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    minimal_service.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Service Client:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import sys\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        # Wait for the service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        # Spin until the future is complete, getting the result\n        rclpy.spin_until_future_complete(self, self.future)\n        if self.future.result() is not None:\n            self.get_logger().info(\n                'Result of add_two_ints: for %d + %d = %d' %\n                (self.req.a, self.req.b, self.future.result().sum))\n        else:\n            self.get_logger().error('Service call failed %r' % (self.future.exception(),))\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    if len(sys.argv) != 3:\n        print('Usage: ros2 run <package_name> minimal_client_async <arg1> <arg2>')\n        return\n    \n    minimal_client = MinimalClientAsync()\n    minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))\n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"32-python-agents-to-ros-controllers",children:"3.2 Python Agents to ROS Controllers"}),"\n",(0,i.jsx)(n.p,{children:"Integrating Python-based AI agents with ROS 2 allows for sophisticated control over robotic platforms. This typically involves an AI agent (e.g., a reinforcement learning agent, a planning algorithm, or a behavioral state machine) making decisions and then translating those decisions into ROS 2 commands."}),"\n",(0,i.jsx)(n.h3,{id:"writing-simple-control-loops-in-python",children:"Writing Simple Control Loops in Python"}),"\n",(0,i.jsx)(n.p,{children:"A common pattern for controlling robots is to implement a control loop within a ROS 2 node. This loop reads sensor data (via subscribers), processes it to make a decision, and then sends commands to the robot (via publishers or service calls)."}),"\n",(0,i.jsxs)(n.p,{children:["Consider a simple agent that tries to keep a robot moving forward while avoiding obstacles detected by a hypothetical ",(0,i.jsx)(n.code,{children:"/scan"})," topic."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist # For sending velocity commands\nfrom sensor_msgs.msg import LaserScan # For receiving laser scan data\n\nclass SimpleNavigationAgent(Node):\n    def __init__(self):\n        super().__init__('simple_navigation_agent')\n        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.scan_callback,\n            10)\n        self.subscription # prevent unused variable warning\n        self.timer = self.create_timer(0.1, self.control_loop) # Control loop runs at 10 Hz\n\n        self.last_scan_data = None\n        self.linear_speed = 0.2\n        self.angular_speed = 0.0\n\n    def scan_callback(self, msg):\n        self.last_scan_data = msg\n\n    def control_loop(self):\n        twist = Twist()\n        if self.last_scan_data is not None:\n            # Simple obstacle avoidance logic: if something is too close in front, turn\n            # Assuming scan.ranges[0] is the front distance\n            front_distance = self.last_scan_data.ranges[len(self.last_scan_data.ranges) // 2] # Approximate front\n            \n            if front_distance < 0.5: # Obstacle too close\n                self.get_logger().info(f'Obstacle detected at {front_distance:.2f}m. Turning.')\n                twist.linear.x = 0.0 # Stop linear motion\n                twist.angular.z = 0.5 # Turn right\n            else:\n                self.get_logger().info(f'Path clear. Moving forward. Front distance: {front_distance:.2f}m')\n                twist.linear.x = self.linear_speed # Move forward\n                twist.angular.z = 0.0 # No turning\n        else:\n            self.get_logger().info('No scan data yet. Robot stopped.')\n            twist.linear.x = 0.0\n            twist.angular.z = 0.0\n            \n        self.publisher_.publish(twist)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    agent = SimpleNavigationAgent()\n    rclpy.spin(agent)\n    agent.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"This example shows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"MinimalAgent"})," node publishing ",(0,i.jsx)(n.code,{children:"Twist"})," messages (linear and angular velocities) to the ",(0,i.jsx)(n.code,{children:"cmd_vel"})," topic, which is a standard topic for controlling mobile robots."]}),"\n",(0,i.jsxs)(n.li,{children:["It subscribes to a ",(0,i.jsx)(n.code,{children:"LaserScan"})," topic to get data from a LiDAR sensor."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"control_loop"})," timer callback processes the sensor data and decides on the robot's next movement, publishing it to ",(0,i.jsx)(n.code,{children:"cmd_vel"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"interfacing-with-simulated-robot-joint-states-and-commands",children:"Interfacing with Simulated Robot Joint States and Commands"}),"\n",(0,i.jsxs)(n.p,{children:["For more complex robots like manipulators or humanoid robots, control often involves sending commands to individual joints and receiving feedback on their current states. This typically relies on understanding the robot's physical structure, as described in the ",(0,i.jsx)(n.a,{href:"understanding-urdf",children:"Understanding URDF"})," chapter."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joint State Publishers:"})," Robots typically publish their current joint angles and velocities on a ",(0,i.jsx)(n.code,{children:"/joint_states"})," topic (message type ",(0,i.jsx)(n.code,{children:"sensor_msgs/JointState"}),"). Your Python agent can subscribe to this topic to understand the robot's current configuration."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joint Trajectory Controllers:"})," For smooth and coordinated motion, robots often expose action interfaces (e.g., ",(0,i.jsx)(n.code,{children:"FollowJointTrajectory"}),") that allow you to send a sequence of target joint positions, velocities, and accelerations over time. Your agent would act as an action client to these interfaces."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach allows agents to command robots at a higher level of abstraction than raw motor commands, focusing on desired poses or trajectories."}),"\n",(0,i.jsxs)(n.h2,{id:"33-advanced-rclpy-features",children:["3.3 Advanced ",(0,i.jsx)(n.code,{children:"rclpy"})," Features"]}),"\n",(0,i.jsx)(n.h3,{id:"timers-and-callbacks",children:"Timers and Callbacks"}),"\n",(0,i.jsx)(n.p,{children:"Timers allow you to schedule functions to be called periodically. This is essential for control loops, data logging, or any task that needs to execute at a fixed rate."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example: Timer callback already shown in the publisher and navigation agent examples.\n# self.timer = self.create_timer(period_in_seconds, self.callback_function)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 nodes can expose parameters that can be dynamically changed at runtime, allowing for flexible configuration without recompiling code."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass ParameterExample(Node):\n    def __init__(self):\n        super().__init__('parameter_example')\n        # Declare a parameter with a default value\n        self.declare_parameter('my_parameter', 'default_value')\n        self.declare_parameter('publish_frequency', 1.0)\n\n        # Get parameter value\n        param_value = self.get_parameter('my_parameter').get_parameter_value().string_value\n        self.get_logger().info(f'Initial parameter value: {param_value}')\n\n        freq = self.get_parameter('publish_frequency').get_parameter_value().double_value\n        self.get_logger().info(f'Publish frequency: {freq} Hz')\n\n        # You can also set a callback for parameter changes\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'my_parameter':\n                self.get_logger().info(f'Parameter \"my_parameter\" changed to: {param.value}')\n            if param.name == 'publish_frequency':\n                self.get_logger().info(f'Parameter \"publish_frequency\" changed to: {param.value} Hz')\n        return rclpy.ParameterResult(successful=True)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ParameterExample()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can change parameters using the ",(0,i.jsx)(n.code,{children:"ros2 param set"})," command:\n",(0,i.jsx)(n.code,{children:'ros2 param set /parameter_example my_parameter "new_value"'}),"\n",(0,i.jsx)(n.code,{children:"ros2 param set /parameter_example publish_frequency 2.0"})]}),"\n",(0,i.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rclpy"})," provides a standard way to log messages with different severity levels (DEBUG, INFO, WARN, ERROR, FATAL)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass LoggerExample(Node):\n    def __init__(self):\n        super().__init__('logger_example')\n        self.get_logger().debug('This is a debug message.')\n        self.get_logger().info('This is an info message.')\n        self.get_logger().warn('This is a warning message.')\n        self.get_logger().error('This is an error message.')\n        self.get_logger().fatal('This is a fatal message.')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = LoggerExample()\n    rclpy.spin_once(node, timeout_sec=1) # Spin once to process logs\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Logging levels can be configured at runtime."})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);