"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[627],{8453(e,n,i){i.d(n,{R:()=>l,x:()=>t});var o=i(6540);const s={},r=o.createContext(s);function l(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),o.createElement(r.Provider,{value:n},e.children)}},9096(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module1-ros2/understanding-urdf","title":"Understanding URDF (Unified Robot Description Format)","description":"The Unified Robot Description Format (URDF) is an XML format for describing all aspects of a robot. It\'s a foundational tool in ROS 2 for representing your robot\'s physical structure, visual appearance, and collision properties. A URDF file allows ROS 2 to understand your robot\'s kinematic and dynamic properties, which is essential for simulation, visualization, motion planning, and more.","source":"@site/docs/module1-ros2/understanding-urdf.md","sourceDirName":"module1-ros2","slug":"/module1-ros2/understanding-urdf","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1-ros2/understanding-urdf","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammad-Rehan/Physical-AI-Humanoid-Robotics-Textbook/edit/main/docs/module1-ros2/understanding-urdf.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Python Agents to ROS Controllers","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1-ros2/python-agents-to-controllers"},"next":{"title":"Simulating Physics in Gazebo","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module2-gazebo/physics-simulation"}}');var s=i(4848),r=i(8453);const l={},t="Understanding URDF (Unified Robot Description Format)",a={},d=[{value:"4.1 Understanding URDF (Unified Robot Description Format)",id:"41-understanding-urdf-unified-robot-description-format",level:2},{value:"Links and Joints: Physical and Kinematic Structure",id:"links-and-joints-physical-and-kinematic-structure",level:3},{value:"Coordinate Frames and Transformations",id:"coordinate-frames-and-transformations",level:3},{value:"Visual and Collision Models",id:"visual-and-collision-models",level:3},{value:"4.2 Creating a Simple URDF Model",id:"42-creating-a-simple-urdf-model",level:2},{value:"Defining a Basic Robot Structure (e.g., a 2-DOF arm)",id:"defining-a-basic-robot-structure-eg-a-2-dof-arm",level:3},{value:"Adding Visual Meshes and Collision Geometries",id:"adding-visual-meshes-and-collision-geometries",level:3},{value:"4.3 XACRO: URDF Macros for Reusability",id:"43-xacro-urdf-macros-for-reusability",level:2},{value:"Parameterizing URDF Models",id:"parameterizing-urdf-models",level:3},{value:"Including other XACRO files",id:"including-other-xacro-files",level:3},{value:"4.4 Visualizing URDF Models",id:"44-visualizing-urdf-models",level:2},{value:"Using <code>RViz2</code> to Display Robot Models",id:"using-rviz2-to-display-robot-models",level:3},{value:"Joint State Publishers",id:"joint-state-publishers",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"understanding-urdf-unified-robot-description-format",children:"Understanding URDF (Unified Robot Description Format)"})}),"\n",(0,s.jsxs)(n.p,{children:["The Unified Robot Description Format (URDF) is an XML format for describing all aspects of a robot. It's a foundational tool in ROS 2 for representing your robot's physical structure, visual appearance, and collision properties. A URDF file allows ROS 2 to understand your robot's kinematic and dynamic properties, which is essential for ",(0,s.jsx)(n.a,{href:"pathname:///docs/module2-gazebo/physics-simulation",children:"simulation"}),", visualization, motion planning, and more."]}),"\n",(0,s.jsx)(n.h2,{id:"41-understanding-urdf-unified-robot-description-format",children:"4.1 Understanding URDF (Unified Robot Description Format)"}),"\n",(0,s.jsxs)(n.p,{children:["A URDF file defines a robot as a tree-like structure of ",(0,s.jsx)(n.code,{children:"links"})," connected by ",(0,s.jsx)(n.code,{children:"joints"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"links-and-joints-physical-and-kinematic-structure",children:"Links and Joints: Physical and Kinematic Structure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Links:"})," These represent the rigid bodies of your robot. Each link has a name and can include definitions for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inertial Properties:"})," Mass, center of mass, and inertia tensor, crucial for realistic physics simulation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visual Properties:"})," How the link should appear, including geometry (e.g., box, cylinder, mesh) and material (color, texture)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Properties:"})," How the link interacts with its environment and other links for collision detection, often a simplified version of the visual geometry to save computational resources."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Joints:"})," These define the kinematic and dynamic properties of the connections between links. Each joint connects a ",(0,s.jsx)(n.code,{children:"parent"})," link to a ",(0,s.jsx)(n.code,{children:"child"})," link and has a ",(0,s.jsx)(n.code,{children:"type"})," that specifies its degrees of freedom:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"revolute"}),":"]})," A rotating joint (e.g., a wheel, a shoulder). Requires an ",(0,s.jsx)(n.code,{children:"axis"})," of rotation and ",(0,s.jsx)(n.code,{children:"limit"}),"s (upper/lower position, velocity, effort)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"continuous"}),":"]})," A revolute joint with no position limits (e.g., a continuously spinning wheel)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"prismatic"}),":"]})," A sliding joint (e.g., a linear actuator). Requires an ",(0,s.jsx)(n.code,{children:"axis"})," of translation and ",(0,s.jsx)(n.code,{children:"limit"}),"s."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"fixed"}),":"]})," A rigid connection between two links. Effectively fuses the child link to the parent, removing any degrees of freedom. Useful for mounting sensors or tools."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"planar"}),":"]})," Allows motion in a plane (2 prismatic, 1 revolute)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"floating"}),":"]})," Allows full 6-DOF motion (3 prismatic, 3 revolute). Typically used for the base link of a mobile robot in a simulator."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"coordinate-frames-and-transformations",children:"Coordinate Frames and Transformations"}),"\n",(0,s.jsx)(n.p,{children:"In a URDF, every link implicitly defines its own coordinate frame. Joints define the transformation from the parent link's coordinate frame to the child link's coordinate frame."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"origin"})," tag:"]})," Within a ",(0,s.jsx)(n.code,{children:"<joint>"})," or ",(0,s.jsx)(n.code,{children:"<link>"}),"'s visual/collision element, the ",(0,s.jsx)(n.code,{children:"<origin>"})," tag specifies the position (",(0,s.jsx)(n.code,{children:"xyz"}),") and orientation (",(0,s.jsx)(n.code,{children:"rpy"})," - roll, pitch, yaw) of the child frame relative to the parent frame, or the geometry relative to the link's origin. It's crucial for correctly assembling the robot's structure."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"visual-and-collision-models",children:"Visual and Collision Models"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Visual Models:"})," These are what you see when you visualize your robot in tools like ",(0,s.jsx)(n.code,{children:"RViz"})," or simulation environments like Gazebo. They can be simple primitive shapes (box, cylinder, sphere) or complex 3D meshes (e.g., ",(0,s.jsx)(n.code,{children:".stl"}),", ",(0,s.jsx)(n.code,{children:".dae"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<visual>\n  <origin xyz="0 0 0.05" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n  </geometry>\n  <material name="blue">\n    <color rgba="0 0 0.8 1"/>\n  </material>\n</visual>\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Collision Models:"})," These define the shape used for collision detection. They are often simplified versions of the visual models (e.g., using a bounding box or sphere instead of a complex mesh) to improve performance during physics simulation and collision checking."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision>\n  <origin xyz="0 0 0.05" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n  </geometry>\n</collision>\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"42-creating-a-simple-urdf-model",children:"4.2 Creating a Simple URDF Model"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a very simple URDF for a two-link arm, consisting of a base, a shoulder joint, an upper arm, an elbow joint, and a forearm."}),"\n",(0,s.jsx)(n.h3,{id:"defining-a-basic-robot-structure-eg-a-2-dof-arm",children:"Defining a Basic Robot Structure (e.g., a 2-DOF arm)"}),"\n",(0,s.jsx)(n.p,{children:"Our robot will have:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"base_link"})," (fixed to the world, conceptually)"]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"shoulder_link"})," connected to ",(0,s.jsx)(n.code,{children:"base_link"})," by a ",(0,s.jsx)(n.code,{children:"shoulder_joint"})," (revolute)"]}),"\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"elbow_link"})," connected to ",(0,s.jsx)(n.code,{children:"shoulder_link"})," by an ",(0,s.jsx)(n.code,{children:"elbow_joint"})," (revolute)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"my_arm.urdf"})})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_arm">\n\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.1"/>\n      </geometry>\n      <material name="gray">\n        <color rgba="0.7 0.7 0.7 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Shoulder Joint --\x3e\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="shoulder_link"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/> \x3c!-- Position relative to base_link --\x3e\n    <axis xyz="0 0 1"/> \x3c!-- Rotates around Z-axis --\x3e\n    <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>\n  </joint>\n\n  \x3c!-- Shoulder Link (Upper Arm) --\x3e\n  <link name="shoulder_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.02" length="0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.02" length="0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Elbow Joint --\x3e\n  <joint name="elbow_joint" type="revolute">\n    <parent link="shoulder_link"/>\n    <child link="elbow_link"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/> \x3c!-- Position relative to shoulder_link (end of upper arm) --\x3e\n    <axis xyz="0 0 1"/> \x3c!-- Rotates around Z-axis --\x3e\n    <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>\n  </joint>\n\n  \x3c!-- Elbow Link (Forearm) --\x3e\n  <link name="elbow_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.02" length="0.15"/>\n      </geometry>\n      <material name="green">\n        <color rgba="0 0.8 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.02" length="0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.05"/>\n      <origin xyz="0 0 0.075" rpy="0 0 0"/>\n      <inertia ixx="0.00005" ixy="0.0" ixz="0.0" iyy="0.00005" iyz="0.0" izz="0.00005"/>\n    </inertial>\n  </link>\n\n</robot>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"adding-visual-meshes-and-collision-geometries",children:"Adding Visual Meshes and Collision Geometries"}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, we used primitive shapes (",(0,s.jsx)(n.code,{children:"box"}),", ",(0,s.jsx)(n.code,{children:"cylinder"}),"). For more complex robots, you would typically use 3D meshes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'    <visual>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <mesh filename="package://my_robot_description/meshes/link_visual.stl" scale="0.001 0.001 0.001"/>\n      </geometry>\n      <material name="red">\n        <color rgba="0.8 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <mesh filename="package://my_robot_description/meshes/link_collision.stl" scale="0.001 0.001 0.001"/>\n      </geometry>\n    </collision>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"package://"})," URI scheme is used to locate files relative to a ROS 2 package."]}),"\n",(0,s.jsx)(n.h2,{id:"43-xacro-urdf-macros-for-reusability",children:"4.3 XACRO: URDF Macros for Reusability"}),"\n",(0,s.jsx)(n.p,{children:"Writing long URDF files can be tedious and error-prone. XACRO (XML Macros) is an XML macro language that allows you to use constants, mathematical expressions, and macros to generate URDF. This significantly improves readability, reusability, and maintainability."}),"\n",(0,s.jsxs)(n.p,{children:["To use XACRO, your file extension should typically be ",(0,s.jsx)(n.code,{children:".urdf.xacro"}),". You process it with ",(0,s.jsx)(n.code,{children:"xacro"})," to produce a standard ",(0,s.jsx)(n.code,{children:".urdf"})," file."]}),"\n",(0,s.jsx)(n.h3,{id:"parameterizing-urdf-models",children:"Parameterizing URDF Models"}),"\n",(0,s.jsx)(n.p,{children:"You can define properties like dimensions or masses as variables."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="my_robot" xmlns:xacro="http://ros.org/wiki/xacro">\n\n  <xacro:property name="arm_length" value="0.5" />\n  <xacro:property name="arm_radius" value="0.05" />\n\n  <link name="base_link"/>\n\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="shoulder_link"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-${pi/2}" upper="${pi/2}" effort="10" velocity="1"/>\n  </joint>\n\n  <link name="shoulder_link">\n    <visual>\n      <geometry>\n        <cylinder radius="${arm_radius}" length="${arm_length}"/>\n      </geometry>\n    </visual>\n    <inertial>\n      <mass value="${0.1 * arm_length}"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n</robot>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"${arm_length}"})," and ",(0,s.jsx)(n.code,{children:"${arm_radius}"})," are variables, and ",(0,s.jsx)(n.code,{children:"${pi/2}"})," shows a mathematical expression."]}),"\n",(0,s.jsx)(n.h3,{id:"including-other-xacro-files",children:"Including other XACRO files"}),"\n",(0,s.jsx)(n.p,{children:"You can create modular XACRO files and include them, making it easy to define standard components (e.g., a gripper, a sensor) once and reuse them across different robot models."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="my_complex_robot" xmlns:xacro="http://ros.org/wiki/xacro">\n\n  <xacro:include filename="$(find my_robot_description)/urdf/common_macros.xacro" />\n  <xacro:include filename="$(find my_robot_description)/urdf/arm.xacro" />\n  <xacro:include filename="$(find my_robot_description)/urdf/gripper.xacro" />\n\n  <link name="world"/>\n\n  <joint name="base_joint" type="fixed">\n    <parent link="world"/>\n    <child link="robot_base"/>\n  </joint>\n\n  <link name="robot_base">\n    \x3c!-- ... base visual/collision/inertial ... --\x3e\n  </link>\n\n  \x3c!-- Now instantiate the arm and gripper using the included macros --\x3e\n  <xacro:arm_macro parent_link="robot_base" />\n  <xacro:gripper_macro parent_link="arm_tool_link" />\n\n</robot>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"44-visualizing-urdf-models",children:"4.4 Visualizing URDF Models"}),"\n",(0,s.jsxs)(n.p,{children:["Once you have a URDF (or XACRO) file, the primary tool for visualizing it in ROS 2 is ",(0,s.jsx)(n.code,{children:"RViz2"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"using-rviz2-to-display-robot-models",children:["Using ",(0,s.jsx)(n.code,{children:"RViz2"})," to Display Robot Models"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RViz2"})," is a 3D visualization tool for ROS 2. It allows you to display sensor data, robot models, and planning outputs."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Start ",(0,s.jsx)(n.code,{children:"RViz2"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"rviz2\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Add ",(0,s.jsx)(n.code,{children:"RobotModel"})," Display:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In the ",(0,s.jsx)(n.code,{children:"RViz2"}),' interface, click "Add" in the "Displays" panel.']}),"\n",(0,s.jsxs)(n.li,{children:["Select ",(0,s.jsx)(n.code,{children:"RobotModel"}),' from the list and click "OK".']}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Configure ",(0,s.jsx)(n.code,{children:"RobotModel"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In the ",(0,s.jsx)(n.code,{children:"RobotModel"})," properties, set the ",(0,s.jsx)(n.code,{children:"Description Topic"})," to ",(0,s.jsx)(n.code,{children:"/robot_description"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Set the ",(0,s.jsx)(n.code,{children:"Fixed Frame"})," to ",(0,s.jsx)(n.code,{children:"base_link"})," (or the name of your robot's base link)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Publish the URDF:"}),"\nYou need a node that publishes your robot's URDF to the ",(0,s.jsx)(n.code,{children:"/robot_description"})," topic. This is typically done by the ",(0,s.jsx)(n.code,{children:"robot_state_publisher"})," node.","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Ensure your URDF is in a package and the path is correct\nros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="`cat $(find your_robot_description)/urdf/your_robot.urdf`"\n'})}),"\n","If you're using XACRO, you'll first need to process it:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"xacro $(find your_robot_description)/urdf/your_robot.urdf.xacro > install/your_robot_description/share/your_robot_description/urdf/your_robot.urdf\n# Then run robot_state_publisher as above\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"joint-state-publishers",children:"Joint State Publishers"}),"\n",(0,s.jsxs)(n.p,{children:["To see your robot move in ",(0,s.jsx)(n.code,{children:"RViz2"}),", you also need to publish joint states. The ",(0,s.jsx)(n.code,{children:"joint_state_publisher_gui"})," is a convenient tool for manually controlling joint positions."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Run ",(0,s.jsx)(n.code,{children:"joint_state_publisher_gui"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ros2 run joint_state_publisher_gui joint_state_publisher_gui\n"})}),"\n","This will open a GUI that allows you to manipulate sliders for each revolute and prismatic joint in your URDF. As you move the sliders, ",(0,s.jsx)(n.code,{children:"joint_state_publisher_gui"})," publishes messages to the ",(0,s.jsx)(n.code,{children:"/joint_states"})," topic, and ",(0,s.jsx)(n.code,{children:"robot_state_publisher"})," (which subscribes to ",(0,s.jsx)(n.code,{children:"/joint_states"}),") updates the robot model in ",(0,s.jsx)(n.code,{children:"RViz2"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);